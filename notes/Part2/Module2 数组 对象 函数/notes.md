## 数组

数组：将多个元素(通常是同一类型)按一定顺序排列放到一个集合中，那么这个几个我们就称之为数组。

##### 创建数组

```js{cmd=node}
// 创建数组
var arr = [];
// 创建包含多个数据的数组，数据类型不受限制
var arr2 = [1,true,null,undefined,[7,8],'哈哈'];
// 获取arr2的第三项
console.log(arr2[2]);
// 获取数组长度
console.log(arr.length)
```

##### 获取数组元素

可以通过index来获取对应的某一项的数据，进行下一步操作。

如果索引值超过数组最大项，相当于这一项没有赋值，内部存储的就是undefined。

##### 数组的长度(length属性)

可以操作length拉长或缩短数组长度。

可以定义一个比长度大的索引的值来拉长数组，其中，未定义值的均为undefined

缩短后相当于把元素删除，操作不可逆。

##### 数组的遍历

对数组的每一个元素都访问一遍，使用for循环。

0~arr.length-1
```js{cmd=node}
var arr = [22,45,63,82,97];
// 遍历数组
for(var i = 1;i < arr.length;i++) {
    console.log(arr[i]);
}
```

## 函数

封装一段代码，将来可以重复使用。被封装起来的函数具备某一项特殊的功能，内部封装的一段代码作为一个完整的结构体，要执行就都执行，要不执行就都不执行。 
```js{cmd=node}
function fun() {
    console.log(1);
}
```

##### 函数声明

函数必须先定义后使用。
```js{cmd=node}
function fun(参数) {
    // 封装的结构体

}
// 函数调用
fun();
```

##### 函数调用

一次调用，多次执行。

函数内部语句执行的位置，与函数定义的位置无关，与函数调用位置有关。

##### 函数的参数

参数是局部变量，只能在函数内部使用。

希望函数执行结果可以根据自定义的内容发生一些变化。

函数的参数可以让用户自定义内容，可以接收任意类型的数据，导致函数执行结果根据参数不同，结果也不同。

一个函数可以设置0个或多个参数，参数间使用，分隔。

###### 形参、实参

+---------------------------------------------------------------------------------------------+
|                                                                                             |
|                              形 参                                                            |
|                              ^                                                              |
|                              |                                                              |
|                              |                                                              |
|                function fun(a+b) {                                                          |
|                    console.log(a+b);                                                        |
|                }                                                                            |
|                fun(5,7);                                                                    |
|                  +                                                                          |
|                  |                                                                          |
|                  |                                                                          |
|                  v                                                                          |
|                  实 参                                                                        |
+---------------------------------------------------------------------------------------------+

形参：函数执行时，形参接收实参传递过来的数据，相当于给形参变量进行隐形的赋值过程，参与程序时，结构体中的变量会使用形参接收到的数据。

实参：函数调用时，会先传递给形参对应的位置。

变量部分用的就是形参接收到的实参的数据，整个过程就是传参过程。

形参和实参的个数可以不一样。

函数参数的优点：

1. 想要使用函数，只需知道传递什么参数，执行什么功能即可，不需要知道内部的结构。
2. 使用函数需要有一个API接口说明，告诉使用者参数需要传递什么类型的数据，实现什么功能。

##### 函数的返回值

函数能够通过参数接收数据，也能将函数执行结果返回一个值。

利用函数内部的return关键字设置返回值。

作用：

1. 函数内部如果结构体执行到一个return关键字，会立即停止后面代码的执行。
2. 可以在return关键字后面添加空格，空格后面任意定义一个数据字面量或者表达式，函数在执行完自身功能后，整体会被return矮化成一个表达式，表达式必须求出一个值可以继续参与程序，表达式的值就是return后面的数据。

注意：

​	如果函数没有设置return语句，name函数有默认的返回值undefined；如果函数使用return语句，但是return后面没有任何值，那么函数的返回值也是undefined。

##### 函数表达式
```js{cmd=node}
// 定义一个函数表达式
var a = function fun() {
    console.log(1);
};
var b = function() {
    console.log(2);
};
// 调用
b();
```

注意：

调用时必须使用**变量名**调用。

##### 函数的数据类型

function

函数是一种数据类型，可以参与其他程序。如：作为另一个函数的参数或返回值进行使用。

##### 函数的递归

函数内部可以通过函数名调用函数自身的方式，就是函数递归现象。

递归的次数太多容易出现错误，超出计算机的最大计算能力。

如：斐波那契数列

##### 作用域

函数作用域、全局变量、局部变量。

变量退出作用域后会被销毁，全局变量关闭网页或浏览器才会销毁。

###### 函数作用域

当函数b定义在函数a内部时，只能在函数a内使用，在外部不能调用函数b.

###### 作用域链

函数内部包含函数时，将所有的作用域列出来，就会形成一个作用域链。

###### 遮蔽效应

程序在遇到变量时，会按照由内而外的层级去查找变量，直到找到第一个变量定义。整个过程中会发生内层变量遮蔽外层变量的效果，叫做遮蔽效应。

##### 预解析

JavaScript解析器执行代码时，分为两个过程：预解析过程和代码执行过程。

###### 预解析过程

1. 把变量的声明提升到当前作用域的最前面，只提升声明，不提升赋值

2. 把函数的声明提升到当前作用域的最前面，只提升声明，不提升调用

3. 先提升var，再提升function

   若出现变量名和函数名同名，则函数会覆盖变量内容。

   如果同名函数覆盖同名变量之后，又对该标识符进行赋值操作，此时该标识符内容成为赋的值，再调用函数时，则会报错。

   因此，不要书写相同的标识符给变量和函数，避免出现覆盖。

4. 函数表达式进行的是变量的提升，在函数书写之前调用函数，数据类型会报错。

   因此，定义函数时，最好使用function关键字进行定义，这样函数声明提升可以永远生效。
```js{cmd=node}
// 先调用
console.log(a); // undefined
// 后定义
var a = 1;
```

###### 代码执行过程

在预解析之后，根据新的代码顺序，从上往下按照既定规律执行代码。

##### IIFE自调用函数

即时调用的函数表达式。函数在定义时就会立即调用。

函数表达式定义过程中，将一个函数矮化成了一个表达式，后面加()运算符就可以执行。

###### 方式：

1. 在函数前面添加操作符，将函数矮化成表达式（+ - ()  = !）

###### 优点：

1.IIFE关住了 函数作用域，在外部无法调用。

2.最常用的是()运算符，而且可以使用匿名函数。
```js{cmd=node}
(function(a) {
    console.log(a);
})(1);
```

### 对象

#### 概念

js的对象就是无序属性的集合。

对象的属性可以包含基本值、对象或函数。

对象就是一组没有顺序的值，以键值对形式出现。

对象的行为和特征：

特征：在对象中用属性表示

行为：在对象中用方法表示

#### 对象字面量

##### 创建对象：

###### 1.使用对象字面量赋值给变量

{ }

每条数据都由属性名和属性值组成。k:v

v可以是任意类型的数据。
```js{cmd=node}
// 通过对象字面量创建对象
var person = {
    name: 'zhangsan',
    age: 18,
    sex: 'male',
    sayHi: function() {
        // 在对象内部调用属性方法使用this
        console.log(this.name + '向你sayHi');
    }
}
// 调用对象的属性和方法
console.log(person.name);
console.log(person.age);
console.log(person.sex)
person.sayHi();
// []调用
// []内部是字符串格式的属性名
person["name"];
person["sayHi"];
// 添加属性
person.school = '第一';
// 修改属性
person.age = 18;
// 删除属性
delete person.sex;
```

###### 2.new Object() 创建对象

```js{cmd=node}
// 创建对象
var person = new Object();
// 添加属性和方法
person.name = 'ls';
person.age = 19;
person.sayHi = function() {
    console.log('Hi');
};
```

new在执行时做的事情：

1. new会在内存中创建一个新的空对象
2. new会让this指向这个新的对象
3. 执行构造函数。目的：给新对象加属性和方法
4. new会返回这个新对象

###### 3.工厂函数创建对象

封装new Object()，需要创建类似的对象时，调用该方法即可。
```js{cmd=node}
function createPerson(name,age,sex) {
    var person = new Object();
    person.name = name;
    person.age = age;
    person.sex = sex;
    person.sayHi = function() {
        console.log('Hi');
    };
    return person;
}
var p1 = createPerson('zs',18,'male');
var p2 = createPerson('ls',20,'female');
console.log(p1);
console.log(p2);
```

###### 4.自定义构造函数
```js{cmd=node}
function Person(name,age,sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
}
var p1 = new Person('zs',19,'male');
console.log(p1);

```

#### 对象遍历

for in 循环
```js{cmd=node}
function Person(name,age,sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
}
var p1 = new Person('zs',19,'male');
for(var k in p1) {
    console.log(p1[k]);
}
```

### 复杂类型

###### 简单类型和复杂类型的区别

值类型：简单数据类型，基本数据类型，在存储时，变量中存储的是值本身，因此叫做值类型。

引用类型：复杂数据类型，在存储时，变量存储的仅仅是地址(引用)，因此叫做引用数据类型。

简单类型在内存中存储时，会单独开辟一个空间，互相之间不会影响。

复杂类型在内存中存储：如果将复杂类型的数据复制给一个变量，复杂类型的数据会在内存中创建一个原型，而变量中存储的是指向对象的一个地址，如果将变量赋值给另一个变量，相当于将地址复制一份给新的变量，两个变量的地址相同，指向的是同一个原型，不论哪个地址更改了原型，两个变量下次访问时，都会发生变化。

![](G:\big-front\notes\Part 2\Module2 数组 对象 函数\canvas.png)

JavaScript的对象包含：自定义对象、内置对象、浏览器对象

ECMAscript的对象：自定义对象、内置对象

#### 常用内置对象

##### Math

```js{cmd=node}
// 向上、向下取整
var m = Math.ceil(0.8);
var n = Math.floor(0.8);
console.log(m,n);
// 绝对值
var a = Math.abs('-1');
console.log(a);
// 最大值和最小值
var b = Math.max(10,20,30,52,68);
console.log(b);

```

##### Array

检测某个实例对象是否是某个对象类型

```js{cmd=node}
var arr = new Array();
console.log(arr instanceof Array); // true
```

常用方法：

###### 首尾操作

```js{cmd=node}
// 尾推:参数随意，可以有一个或多个
arr.push(5,6,7,8);
// 删除最后一项,无需传参，返回删除项
arr.pop();
// 删除第一项，返回删除项
arr.shift();
// 首添，参数与push类似
arr.unshift(-1,0);
```

###### 合并和拆分
```js{cmd=node}
// 合并
var arr1 = [1,2,3,4];
var arr2 = [5,6,7,8];
var arr3 = arr1.concat(arr2);
// 拆分slice 
// 从当前数组中截取一个新的数组，不影响原来的数组，返回一个新数组，包含从start到end(不包含)的元素。
// 参数区分正负，负值表示从后往前数第几个位置，参数可以只传递一个，表示从开始位置截取到字符串结尾
var arr4 = arr3.slice(3,5);// [4,5]
var arr5 = arr3.slice(-5,-1);// [4,5,6,7]
```

###### 删除、插入、替换

splice(index,howmany,element1,element2)
```js{cmd=node}
// 删除 传前两个参数 删除的项为返回值
var arr = [1,2,3,4,5,6,7,8,9];
// arr.splice(2,5);
// 替换：传三个及以上的参数
arr.splice(2,5,'111','222');
console.log(arr);
// 插入：传三个及以上参数，但第二个参数必须为0
arr.splice(2,0,'xixi');
console.log(arr);
```

indexOf()  查找数据在数组中最先出现的下标。

lastIndexOf()  查找数据在数组中最后一次出现的下标

注意：如果没找到返回-1.

###### 排序

reverse()  倒序排列

sort()  按ASCII码从小到大排列

​	如果想按数值大小排序，必须添加sort的比较函数参数。该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数a和b,根据a和b的关系作为判断条件，返回值根据条件分为三个分支：-1--a在b前；1--a在b后；0--a和b的顺序保持不变。
```js{cmd=node}
var arr = [1,2,3,4,5,6,7,8,9];
// 降序排列
arr.sort(function(a,b){
    if(a < b){
        return 1;
    } else if(a > b){
        return -1;
    } else{
        return 0;
    }
});
console.log(arr);
```

###### 转字符串

join()  以连字符进行连接。
```js{cmd=node}
var arr = [1,2,3,4,5,6,7,8,9];
console.log(arr.join('#'));
```

Array.from():从类数组对象或可迭代对象中创建一个新的数组实例

Array.prototype.concat();返回一个由当前数组和其他若干数组或若干个非数组值组合成的新数组

##### String

基本包装类型：

基本类型的数据在进行一些特殊操作时，会暂时被包装成一个对象，结束后再被销毁。

字符串特点：

1. 不可变。因此在大量拼接字符串的时候会影响效率问题。
2. 字符串的所有方法都不会改变字符串本身，操作完成会返回一个新的字符串。

**属性**

stringth : 字符串长度

**方法**

charAt()可返回指定位置的字符

indexOf()  返回字符串在原始字符串中第一次出现的地方。没有时返回-1.

concat()  连接两个或多个字符串，生成新的字符串。

split()  分割字符串成一个数组

toLowerCase()

toUpperCase()

slice()  提取字符串的某个部分

substr()  方法可再字符串中抽取从start下标开始的指定数目的字符

* substr(start,howmany)
* 从开始位置截取到指定长度的字符串
* start区分正负
* how满意必须为正数或不写，不写表示截取到最后。

subString(start,end)

* 截取前会比较两个数的大小，小的作为开始，大的作为结束。

