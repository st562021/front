## 数组

数组：将多个元素(通常是同一类型)按一定顺序排列放到一个集合中，那么这个几个我们就称之为数组。

##### 创建数组

```js{cmd=node}
// 创建数组
var arr = [];
// 创建包含多个数据的数组，数据类型不受限制
var arr2 = [1,true,null,undefined,[7,8],'哈哈'];
// 获取arr2的第三项
console.log(arr2[2]);
// 获取数组长度
console.log(arr.length)
```

##### 获取数组元素

可以通过index来获取对应的某一项的数据，进行下一步操作。

如果索引值超过数组最大项，相当于这一项没有赋值，内部存储的就是undefined。

##### 数组的长度(length属性)

可以操作length拉长或缩短数组长度。

可以定义一个比长度大的索引的值来拉长数组，其中，为定义值的均为undefined

缩短后相当于把元素删除，操作不可逆。

##### 数组的遍历

对数组的每一个元素都访问一遍，使用for循环。

0~arr.length-1
```js{cmd=node}
var arr = [22,45,63,82,97];
// 遍历数组
for(var i = 1;i < arr.length;i++) {
    console.log(arr[i]);
}
```

## 函数

封装一段代码，将来可以重复使用。被封装起来的函数具备某一项特殊的功能，内部封装的一段代码作为一个完整的结构体，要执行就都执行，要不执行就都不执行。 
```js{cmd=node}
function fun() {
    console.log(1);
}
```

##### 函数声明

函数必须先定义后使用。
```js{cmd=node}
function fun(参数) {
    // 封装的结构体

}
// 函数调用
fun();
```

##### 函数调用

一次调用，多次执行。

函数内部语句执行的位置，与函数定义的位置无关，与函数调用位置有关。

##### 函数的参数

参数是局部变量，只能在函数内部使用。

希望函数执行结果可以根据自定义的内容发生一些变化。

函数的参数可以让用户自定义内容，可以接收任意类型的数据，导致函数执行结果根据参数不同，结果也不同。

一个函数可以设置0个或多个参数，参数间使用，分隔。

###### 形参、实参

+---------------------------------------------------------------------------------------------+
|                                                                                             |
|                              形 参                                                            |
|                              ^                                                              |
|                              |                                                              |
|                              |                                                              |
|                function fun(a+b) {                                                          |
|                    console.log(a+b);                                                        |
|                }                                                                            |
|                fun(5,7);                                                                    |
|                  +                                                                          |
|                  |                                                                          |
|                  |                                                                          |
|                  v                                                                          |
|                  实 参                                                                        |
+---------------------------------------------------------------------------------------------+

形参：函数执行时，形参接收实参传递过来的数据，相当于给形参变量进行隐形的赋值过程，参与程序时，结构体中的变量会使用形参接收到的数据。

实参：函数调用时，会先传递给形参对应的位置。

变量部分用的就是形参接收到的实参的数据，整个过程就是传参过程。

形参和实参的个数可以不一样。

函数参数的优点：

1. 想要使用函数，只需知道传递什么参数，执行什么功能即可，不需要知道内部的结构。
2. 使用函数需要有一个API接口说明，告诉使用者参数需要传递什么类型的数据，实现什么功能。

##### 函数的返回值

函数能够通过参数接收数据，也能将函数执行结果返回一个值。

利用函数内部的return关键字设置返回值。

作用：

1. 函数内部如果结构体执行到一个return关键字，会立即停止后面代码的执行。
2. 可以在return关键字后面添加空格，空格后面任意定义一个数据字面量或者表达式，函数在执行完自身功能后，整体会被return矮化成一个表达式，表达式必须求出一个值可以继续参与程序，表达式的值就是return后面的数据。

注意：

​	如果函数没有设置return语句，name函数有默认的返回值undefined；如果函数使用return语句，但是return后面没有任何值，那么函数的返回值也是undefined。

##### 函数表达式
```js{cmd=node}
// 定义一个函数表达式
var a = function fun() {
    console.log(1);
};
var b = function() {
    console.log(2);
};
// 调用
b();
```

注意：

调用时必须使用**变量名**调用。

##### 函数的数据类型

function

函数是一种数据类型，可以参与其他程序。如：作为另一个函数的参数或返回值进行使用。

##### 函数的递归

函数内部可以通过函数名调用函数自身的方式，就是函数递归现象。

递归的次数太多容易出现错误，超出计算机的最大计算能力。

如：斐波那契数列

##### 作用域

函数作用域、全局变量、局部变量。

变量退出作用域后会被销毁，全局变量关闭网页或浏览器才会销毁。

###### 函数作用域

当函数b定义在函数a内部时，只能在函数a内使用，在外部不能调用函数b.

###### 作用域链

函数内部包含函数时，将所有的作用域列出来，就会形成一个作用域链。

###### 遮蔽效应

程序在遇到变量时，会按照由内而外的层级去查找变量，直到找到第一个变量定义。整个过程中会发生内层变量遮蔽外层变量的效果，叫做遮蔽效应。

##### 预解析

JavaScript解析器执行代码时，分为两个过程：预解析过程和代码执行过程。

###### 预解析过程

1. 把变量的声明提升到当前作用域的最前面，只提升声明，不提升赋值

2. 把函数的声明提升到当前作用域的最前面，只提升声明，不提升调用

3. 先提升var，再提升function

   若出现变量名和函数名同名，则函数会覆盖变量内容。

   如果同名函数覆盖同名变量之后，又对该标识符进行赋值操作，此时该标识符内容成为赋的值，再调用函数时，则会报错。

   因此，不要书写相同的标识符给变量和函数，避免出现覆盖。

4. 函数表达式进行的是变量的提升，在函数书写之前调用函数，数据类型会报错。

   因此，定义函数时，最好使用function关键字进行定义，这样函数声明提升可以永远生效。
```js{cmd=node}
// 先调用
console.log(a); // undefined
// 后定义
var a = 1;
```

###### 代码执行过程

在预解析之后，根据新的代码顺序，从上往下按照既定规律执行代码。

##### IIFE自调用函数

即时调用的函数表达式。函数在定义时就会立即调用。

函数表达式定义过程中，将一个函数矮化成了一个表达式，后面加()运算符就可以执行。

###### 方式：

1. 在函数前面添加操作符，将函数矮化成表达式（+ - ()  = !）

###### 优点：

1.IIFE关住了 函数作用域，在外部无法调用。

2.最常用的是()运算符，而且可以使用匿名函数。
```js{cmd=node}
(function(a) {
    console.log(a);
})(1);
```

### 对象

#### 概念

js的对象就是无序属性的集合。

对象的属性可以包含基本值、对象或函数。

对象就是一组没有顺序的值，以键值对形式出现。

对象的行为和特征：

特征：在对象中用属性表示

行为：在对象中用方法表示

#### 对象字面量

##### 创建对象：

###### 1.使用对象字面量赋值给变量

{ }

每条数据都由属性名和属性值组成。k:v

v可以是任意类型的数据。
```js{cmd=node}
// 通过对象字面量创建对象
var person = {
    name: 'zhangsan',
    age: 18,
    sex: 'male',
    sayHi: function() {
        // 在对象内部调用属性方法使用this
        console.log(this.name + '向你sayHi');
    }
}
// 调用对象的属性和方法
console.log(person.name);
console.log(person.age);
console.log(person.sex)
person.sayHi();
// []调用
// []内部是字符串格式的属性名
person["name"];
person["sayHi"];
// 添加属性
person.school = '第一';
// 修改属性
person.age = 18;
// 删除属性
delete person.sex;
```

###### 2.new Object() 创建对象

```js{cmd=node}
// 创建对象
var person = new Object();
// 添加属性和方法
person.name = 'ls';
person.age = 19;
person.sayHi = function() {
    console.log('Hi');
};
```

new在执行时做的事情：

1. new会在内存中创建一个新的空对象
2. new会让this指向这个新的对象
3. 执行构造函数。目的：给新对象加属性和方法
4. new会返回这个新对象

###### 3.工厂函数创建对象

封装new Object()，需要创建类似的对象时，调用该方法即可。
```js{cmd=node}
function createPerson(name,age,sex) {
    var person = new Object();
    person.name = name;
    person.age = age;
    person.sex = sex;
    person.sayHi = function() {
        console.log('Hi');
    };
    return person;
}
var p1 = createPerson('zs',18,'male');
var p2 = createPerson('ls',20,'female');
console.log(p1);
console.log(p2);
```

###### 4.自定义构造函数
```js{cmd=node}
function Person(name,age,sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
}
var p1 = new Person('zs',19,'male');
console.log(p1);

```

#### 对象遍历

for in 循环
```js{cmd=node}
function Person(name,age,sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
}
var p1 = new Person('zs',19,'male');
for(var k in p1) {
    console.log(p1[k]);
}
```

### 复杂类型

###### 简单类型和复杂类型的区别

值类型：简单数据类型，基本数据类型，在存储时，变量中存储的是值本身，因此叫做值类型。

引用类型：复杂数据类型，在存储时，变量存储的仅仅是地址(引用)，因此叫做引用数据类型。

简单类型在内存中存储时，会单独开辟一个空间，互相之间不会影响。

复杂类型在内存中存储：如果将复杂类型的数据复制给一个变量，复杂类型的数据会在内存中创建一个原型，而变量中存储的是指向对象的一个地址，如果将变量赋值给另一个变量，相当于将地址复制一份给新的变量，两个变量的地址相同，指向的是同一个原型，不论哪个地址更改了原型，两个变量下次访问时，都会发生变化。

![](G:\big-front\notes\Part 2\Module2 数组 对象 函数\canvas.png)

JavaScript的对象包含：自定义对象、内置对象、浏览器对象

ECMAscript的对象：自定义对象、内置对象

#### 常用内置对象

##### Math

```js{cmd=node}
// 向上、向下取整
var m = Math.ceil(0.8);
var n = Math.floor(0.8);
console.log(m,n);
// 绝对值
var a = Math.abs('-1');
console.log(a);
// 最大值和最小值
var b = Math.max(10,20,30,52,68);
console.log(b);

```

##### Array

检测某个实例对象是否是某个对象类型

```js{cmd=node}
var arr = new Array();
console.log(arr instanceof Array); // true
```

常用方法：

###### 首尾操作

```js{cmd=node}
// 尾推:参数随意，可以有一个或多个
arr.push(5,6,7,8);
// 删除最后一项,无需传参，返回删除项
arr.pop();
// 删除第一项，返回删除项
arr.shift();
// 首添，参数与push类似
arr.unshift(-1,0);
```

###### 合并和拆分
```js{cmd=node}
// 合并
var arr1 = [1,2,3,4];
var arr2 = [5,6,7,8];
var arr3 = arr1.concat(arr2);
// 拆分slice 
// 从当前数组中截取一个新的数组，不影响原来的数组，返回一个新数组，包含从start到end(不包含)的元素。
// 参数区分正负，负值表示从后往前数第几个位置，参数可以只传递一个，表示从开始位置截取到字符串结尾
var arr4 = arr3.slice(3,5);// [4,5]
var arr5 = arr3.slice(-5,-1);// [4,5,6,7]
```

###### 删除、插入、替换

splice(index,howmany,element1,element2)
```js{cmd=node}
// 删除 传前两个参数 删除的项为返回值
var arr = [1,2,3,4,5,6,7,8,9];
// arr.splice(2,5);
// 替换：传三个及以上的参数
arr.splice(2,5,'111','222');
console.log(arr);
// 插入：传三个及以上参数，但第二个参数必须为0
arr.splice(2,0,'xixi');
console.log(arr);
```

indexOf()  查找数据在数组中最先出现的下标。

lastIndexOf()  查找数据在数组中最后一次出现的下标

注意：如果没找到返回-1.

###### 排序

reverse()  倒序排列

sort()  按ASCII码从小到大排列

​	如果想按数值大小排序，必须添加sort的比较函数参数。该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数a和b,根据a和b的关系作为判断条件，返回值根据条件分为三个分支：-1--a在b前；1--a在b后；0--a和b的顺序保持不变。
```js{cmd=node}
var arr = [1,2,3,4,5,6,7,8,9];
// 降序排列
arr.sort(function(a,b){
    if(a < b){
        return 1;
    } else if(a > b){
        return -1;
    } else{
        return 0;
    }
});
console.log(arr);
```

###### 转字符串

join()  以连字符进行连接。
```js{cmd=node}
var arr = [1,2,3,4,5,6,7,8,9];
console.log(arr.join('#'));
```

##### String

基本包装类型：

基本类型的数据在进行一些特殊操作时，会暂时被包装成一个对象，结束后再被销毁。

字符串特点：

1. 不可变。因此在大量拼接字符串的时候会影响效率问题。
2. 字符串的所有方法都不会改变字符串本身，操作完成会返回一个新的字符串。

**属性**

stringth : 字符串长度

**方法**

charAt()可返回指定位置的字符

indexOf()  返回字符串在原始字符串中第一次出现的地方。没有时返回-1.

concat()  连接两个或多个字符串，生成新的字符串。

split()  分割字符串成一个数组

toLowerCase()

toUpperCase()

slice()  提取字符串的某个部分

substr()  方法可再字符串中抽取从start下标开始的指定数目的字符

* substr(start,howmany)
* 从开始位置截取到指定长度的字符串
* start区分正负
* how满意必须为正数或不写，不写表示截取到最后。

subString(start,end)

* 截取前会比较两个数的大小，小的作为开始，大的作为结束。

