# JavaScript高级特性

**对象**

无序属性的集合，其属性可以包含基本值、对象或函数。

## **面向对象**--OOP

**面向对象的特性：**

封装、继承、抽象

**总结：**

在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。

因此，面向对象编程具有灵活、代码可服用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程，更适合多人合作的大型软件项目。

##### 面向对象设计思想：

* 抽象出class(构造函数)
* 根据构造函数创建Instance(实例)
* 指挥instance得出结果

##### 创建对象的几种方法

##### 构造函数和实例对象的关系

构造函数是根据具体的食物抽象出来的抽象模板

实例对象是根据抽象的构造函数模板得到的具体实例对象

每一个实例对象都通过一个constructor属相，指向创建该实例的构造函数。(constructor是实例的属性 这种说法不严谨)

推荐使用instanceof操作符来判断实例和构造函数之间的关系。

###### 静态成员和实例成员

实例成员：在构造函数内部添加给this的成员，属于实例对象的成员，在创建实例对象后必须由对象调用

静态成员：添加给构造函数自身的成员，只能使用构造函数调用，不能使用生成的实例对象调用。

###### 构造函数的问题

浪费内存

每创建一次对象，对象内的函数及属性就会创建一次，极大的浪费内存。

解决1：将公共函数提取出来，但是会造成在全局作用域中命名冲突的问题。

解决：将函数封装到一个函数对象内，统一由这个对象进行调用。但是不符合面向对象编程思想(使用了中间手段解决问题，并没有全部放在创建的对象内)。

#### 原型

使用原型对象可以更好的解决构造函数的内存浪费问题。

把所有对象实例需要共享的属性和方法直接定义在prototype对象上

##### prototype原型对象

* 任何函数都具有一个prototype属性，该属性是一个对象
* 可以在原型对象上添加属性和方法
* 构造函数的prototype对象默认都有一个constructor属性，指向prototype对象所在函数
* 通过构造函数得到的实例对象内部会包含一个指向构造函数的prototype对象的指针：__proto__
* 这个原型对象的所有属性和方法，都会被构造函数的实例对象所拥有
* 实例对象可以直接访问原型对象成员

##### 构造函数、实例、原型对象三者之间的关系

![](G:\front\notes\Part 2\Module 4 JavaScript高级特性及ES6\原型关系.png)

##### 内置构造函数的原型对象

不允许使用对象替换的方式更改内置原型对象的prototype。

可以通过打点添加属性的方式进行修改。(实际工作中不允许修改内置原型对象)

#### 原型链

![](G:\front\notes\Part 2\Module 4 JavaScript高级特性及ES6\原型链.png)

##### 原型链查找机制

每当代码读取到某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性：

1. 搜索首先从对象实例本身开始
2. 如果在实例中找到了具有给定名字的属性，则返回该属性的值
3. 如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字 的属性
4. 如果在原型对象中找到了这个属性，则返回该属性的值

###### 实例对象读写原型对象成员

读：

1. 先在自己身上找，找到即返回
2. 自己身上找不到，则沿着原型链向上查找，找到即返回
3. 如果一直找到原型链的末端还没有找到，则返回undefined

写：

**值类型、引用类型成员**写入(实例对象.值类型成员或引用类型成员 = XX)：

* 当实例期望重写原型对象中的某个普通数据成员时实际上会把该成员添加到自己身上
* 也就是说该行为实际上会屏蔽掉对原型对象成员的访问

**复杂类型成员**修改(实例对象.成员.XX = XX)

* 先在自己身上找该成员，如果自己身上找到则直接修改
* 如果自己身上找不到，则沿着原型链继续查找，如果找到则修改
* 如果一直到原型链的末端还没有找到该成员，则报错(undefined).

创建数组后并没有给数组手动添加方法和属性，但却可以调用。

原因：原型链向上查找，自己没有的东西，会从原型对象中查找，以此类推，层层向上，最终依然找不到时，返回空。

##### 原型对象使用建议

在定义构造函数时，可以根据成员的功能不同，分别进行设置：

* 私有成员(一般就是非函数成员)放到构造函数中
* 共享成员(一般就是函数)放到原型对象中
* 如果重置了prototype记得修正constructor的指向

##### call方法
```js{cmd=node}
// 函数本身就是一种对象，能够有自己的属性和方法
// call方法本身是一种执行函数的方法
function fn(a,b){
    console.log(this);
    console.log(a+b);
}
var o = {name:'zs'};
fn.call(o,3,4);
```

## 继承

继承指的是类型和类型之间的继承

###### 组合继承

属性在构造函数内部继承，方法通过原型继承

## 函数

定义函数的两种方式：函数声明和函数表达式

函数本身也是对象

###### 函数调用时内部this的默认指向

普通函数：指向window

构造函数：指向将来创建的实例对象

对象函数：指向调用函数的对象自己

事件函数：指向事件源

定时器、延时器函数：指向window

**但是this到底指向什么要看调用时的环境来确定**